%% generate_dataset.m
% Generate a dataset of synthetic hand poses. For each hand pose, we save
% - a synthetic depthmap, generated by means of 3D rendering
% - the global hand 3D rotation, i.e. its orientation within the virtual
% scene

%% Dataset generations variables
% Hand rendering parameters
RENDER_WIDTH=320;
RENDER_HEIGHT=240;
RENDER_NEAR=20;
RENDER_FAR=80;
RENDER_FX=240.3077;
RENDER_FY=240.0749;
RENDER_HFOV=rad2deg(2.*atan(RENDER_WIDTH/(2*RENDER_FX)));
RENDER_VFOV=rad2deg(2.*atan(RENDER_HEIGHT/(2*RENDER_FY)));
RENDER_MODELPATH='../../rgbd_ground_truth_generator/test_models/hand.dae';

% Hand positioning parameters (cm)
HAND_TX = 0;
HAND_TY = 5;
HAND_TZ = 50;

% Bounding box parameters (cm)
BBOX_RADIUS=12;
BBOX_WRIST_OFFSET=8;

% Pose perturbations parameters
POSE_N_PERTURBED = 3;
POSE_G_T_SIGMA = 20;
POSE_G_ROT_SIGMA = 30;
POSE_WRIST_SIGMA = 10;
POSE_FINGER_SIGMA = 5;

% Output directories
DATASET_OUTPATH = [pwd() '/out'];

% Base rotations file
%CLUSTERS_PATH = 'quat.mat';
BASE_ROT_FILE_PATH = '../data/base_rot.mat';


%% Initialization
% Load LIS poses
hand_poses;

% Load base poses' rotation
load(BASE_ROT_FILE_PATH); %C=cl128refinedquat; %C=quat;
N_BASE_ROT = size(C,1);

% Initialize the hand renderer
mrInst = model_renderer_new(RENDER_WIDTH, RENDER_HEIGHT, ...
                            RENDER_MODELPATH, ...
                            RENDER_HFOV, RENDER_VFOV, ...
                            RENDER_NEAR, RENDER_FAR);

% Init the pose matrix. We keep two matrices: one for global translation
% and one for global and local (i.e. bones) rotations.
N_POSES = N_BASE_ROT*N_LIS_POSES*POSE_N_PERTURBED;
t = zeros(N_POSES, 3);
poses = zeros(N_POSES, hand_utils.HAND_POSE_LEN);

% We also keep a vector for the 2D bounding box
bboxes = zeros(N_POSES, 4);

% ... and hand centroid
c = zeros(N_POSES, 3);

% Sorted bones idx
sortBoneIdx = arrayfun(@(i) model_renderer_getboneidx(mrInst, hand_utils.HAND_BONE_NAME{i})+1, ...
                       1:model_renderer_getbonesnum(mrInst));

                   
%% Poses' generation
% Iterate over clusters and poses ...
for i=1:N_BASE_ROT
   baseRot = C(i,:);
   for j=1:N_LIS_POSES
      basePose = LIS_POSE(j,:);
      
      % ... and generate the perturbed pose
      for k=1:POSE_N_PERTURBED
         currPoseId = (i-1)*N_LIS_POSES*POSE_N_PERTURBED + ...
             (j-1)*POSE_N_PERTURBED + k;
         currPoseSigma = zeros(hand_utils.HAND_POSE_LEN);
         
         % Perturb the fingers and wrist (with different variance)
         currPoseSigma(4:5) = POSE_WRIST_SIGMA;
         currPoseSigma(6:end) = POSE_FINGER_SIGMA;
         currPose = basePose; currPose(4:5) = 0;
         currPose = hand_utils.perturb_pose(currPose, currPoseSigma);
         
         % Perturb the global rotation
         currRot = hand_utils.perturb_rotation(baseRot, POSE_G_ROT_SIGMA);
         [z,y,x] = quat2angle(currRot, 'ZYX');
         currPose(1:3) = rad2deg([x y z]);
         
         % Done with current pose
         poses(currPoseId,:) = currPose;
         
         % Finnaly, perturb the global translation and generate the
         % bounding box
         pt = normrnd([HAND_TX, HAND_TY, HAND_TZ], POSE_G_T_SIGMA);
         
         % Get the hand centroid
         % TODO: instead of getting the centroid by a BBOX_WRIST_OFFSET cm offset with
         % respect to hand X axis, use the palm joint position
         handAxis =  quat2rotm(currRot);
         handCentroid = (pt + handAxis(:,1)'*BBOX_WRIST_OFFSET);
         
         % Constrain the hand position within the view frustum
         handCentroid(3) = -min(max(abs(handCentroid(3)), RENDER_NEAR+BBOX_RADIUS), ...
                                RENDER_FAR-BBOX_RADIUS);
         xBound = RENDER_WIDTH/2/RENDER_FX*abs(handCentroid(3))-BBOX_RADIUS;
         yBound = RENDER_HEIGHT/2/RENDER_FY*abs(handCentroid(3))-BBOX_RADIUS;
         handCentroid(1) = min(max(handCentroid(1), -xBound), xBound); 
         handCentroid(2) = min(max(handCentroid(2), -yBound), yBound);
         
         % Save the hand translation and centroid
         t(currPoseId,:) = handCentroid-handAxis(:,1)'*BBOX_WRIST_OFFSET;
         c(currPoseId,:) = handCentroid;
         
         % Compute the bounding box 2D coordinates and constrain it on
         % image plane
         bboxU = [handCentroid(1)-BBOX_RADIUS, handCentroid(1)+BBOX_RADIUS]/ ...
                 abs(handCentroid(3))*RENDER_FX + RENDER_WIDTH/2;
         bboxV = -[handCentroid(2)-BBOX_RADIUS, handCentroid(2)+BBOX_RADIUS]/ ...
                 abs(handCentroid(3))*RENDER_FY + RENDER_HEIGHT/2;
         bboxU = min(max(bboxU,0), RENDER_WIDTH-1);
         bboxV = min(max(bboxV,0), RENDER_HEIGHT-1);
         bboxes(currPoseId,:) = [bboxU(1)+1, bboxV(2)+1, ...
                                 bboxU(2)-bboxU(1), bboxV(1)-bboxV(2)];
         
      end
   end
end

%% Poses' rendering
% Prepare directories
mkdir(DATASET_OUTPATH);
mkdir([DATASET_OUTPATH '/dataset'])

% Keep also two files where, for each row, we have the path of the saved
% synthetic depthmap and its orientation (in XYZ Euler angles),
% respectively
depthListFile = fopen([DATASET_OUTPATH '/depth_list.txt'], 'wb');
eulerAnglesFile = fopen([DATASET_OUTPATH '/euler_angles.txt'], 'wb');

for i=1:N_POSES
    currPoseMat = hand_utils.pose2rotm(poses(i,:));
    currPoseMat(:,:,sortBoneIdx) = currPoseMat;
    
    % Set the global translation
    currPoseMat(1:3,4,1) = t(i,:);
 
    % Render the pose and save it
    % Note: labels are discarded since not needed
    model_renderer_setpose(mrInst, currPoseMat);
    [~,depth] = model_renderer_render(mrInst);

    % Save the rendered hand
    %imwrite(colour, [DATASET_OUTPATH '/dataset/pose' num2str(i) '_labels.png'], ...
    %        'Mode', 'lossless', 'BitDepth', 8);
    imwrite(depth, [DATASET_OUTPATH '/dataset/pose' num2str(i) '_depth.png'], ...
            'Mode', 'lossless', 'BitDepth', 16);
        
    % and the data about pose and bounding box
    location = t(i,:);
    centroid = c(i,:);
    pose = poses(i,:);
    bbox = bboxes(i,:);
    save([DATASET_OUTPATH '/dataset/pose' num2str(i) '_data.mat'], ...
         'location', 'centroid', 'pose', 'bbox');
 
    % update the depthListFile and EulerAnglesFile as well
    fprintf(depthListFile, '%s\n', [DATASET_OUTPATH '/dataset/pose' num2str(i) '_depth.png']);
    fprintf(eulerAnglesFile, '%.4f %.4f %.4f\n', poses(i,1), poses(i,2), poses(i,3));
end

% Save parameters
save([DATASET_OUTPATH '/params.mat'], 'C','RENDER_WIDTH', 'RENDER_HEIGHT', ...
     'RENDER_NEAR', 'RENDER_FAR', 'RENDER_FX', 'RENDER_FY', 'RENDER_HFOV', 'RENDER_VFOV', ...
     'RENDER_MODELPATH', 'HAND_TX', 'HAND_TY', 'HAND_TZ', 'BBOX_RADIUS', 'BBOX_WRIST_OFFSET',...
     'POSE_N_PERTURBED', 'POSE_G_T_SIGMA', 'POSE_G_ROT_SIGMA', 'POSE_WRIST_SIGMA', ...
     'POSE_FINGER_SIGMA');

%% Cleanup
model_renderer_delete(mrInst);